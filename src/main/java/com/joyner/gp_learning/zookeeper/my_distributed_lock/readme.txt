基于zookeeper实现分布式锁，思路

1.需要争抢锁，只有一个人能获取锁
2.获取锁的人出问题，则需要释放锁（使用临时节点实现）
3.获取锁的人成功了之后，最后需要释放锁
4.实现方式
（1）主动轮询，心跳    弊端：压力，延迟
例如有9000个客户端争抢锁，那么会给zookeeper带来很大的压力
（2）watch：解决了延迟的问题，但是同样会带来压力问题
因为节点已发生变化，需要通知所有的节点
（3）sequence节点 + watch,watch前一个节点，最小的会获取锁，一旦最小的释放了锁就会通知后面的。也就是队列锁

例如：有5个客户端争抢锁

e_lock01, e_lock02, e_lock03, e_lock04, e_lock05
这种情况e_lock01获取锁，
e_lock02->watch->e_lock01
e_lock03->watch->e_lock02
e_lock04->watch->e_lock03
e_lock05->watch->e_lock04

备注：1.e_lock02 里面的e_表示Ephemeral，也就是临时节点
     2.先创建节点，然后获取children，对children进行排序，判断是否自己是最小的，如果是则获取锁。
     如果没有获取到锁，则观察前一个节点，然后重新获取children，判断自己是否能获取锁。
     3.如果某个节点创建成功，则其前面的节点必然已经创建成功


场景1. 如果e_lock04断了，也就是死掉了，那么首选会通知e_lock05，e_lock05获取到通知之后，重新获取子节点，然后再去监听e_lock03

